{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf230
{\fonttbl\f0\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\fs24 \cf0 1. Chapter 11, Problem 4\
\
What are the disadvantages of designing an abstract data type to be a pointer?\
\
One disadvantage is that comparing equality becomes ambiguous; do the pointers need to be equal? Or the structures referenced by the pointers?\
\
2. Chapter 11, Problem 6\
\
What dangers are avoided in Java by having implicit garbage collection, relative to C++?\
\
Having implicit garbage collection means that the programmer does not have to remember to destroy allocated data. It is harder to have memory leaks with implicit garbage collection.\
\
3. Chapter 12, Problem 7\
\
Explain the two problems with abstract data types that are ameliorated by inheritance.\
\
One problem is that it is sometimes inconvenient to reuse code with abstract data types; often, a new type will often need minor modifications, which means changing all client programs. The other problem is that all of the type definitions are independent and at the same level. This design makes it impossible to design data types to more closely match the problem spec of the program.\
\
4. Chapter 14, Problem 9\
\
fun1.i is handled by fun2's catch(int).\
fun1.f is handled by fun1's catch(float).\
fun2.j is handled by fun2's catch(int).\
fun2.g is handled y fun2's catch(float).}