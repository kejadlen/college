maple('Restart()');
maple('DeclareObservers(W,Tree,Hill)');
maple('DeclarePoints(W,Tree,Hill,Tree1,Tree2)');
maple('DeclareTriads(w,tree,hill)');

maple(['DefineObservers('...
    '[W,W,w],[Tree,Tree,tree],[Hill,Hill,hill])']);
maple(['DefinePoints('...
    '[W,Tree,w,q1,q2,q3],'...
    '[Tree,Tree1,tree,0,0,L/2],'...
    '[Tree,Tree2,tree,0,0,-L/2],'...
    '[W,Hill,w,p1,p2,p3])']);
maple(['DefineTriads('...
    '[w,tree,[q4,3],[q5,1],[q6,3]],'...
    '[w,hill,[p4,3],[p5,1],[p6,3]])']);
maple('DefineNeighbors([W,Tree],[W,Hill])');

maple(['DefineObjects('...
    '[Tree,''Cylinder'',length=L,radius=R,'...
        'color="{0.55,0.27,0.07}"],'...
    '[Hill,''Block'',xlength=10,ylength=10,'...
        'zlength=.01,color="{0,0.39,0}"])']);

maple('DeclareStates(q1,q2,q3,q4,q5,q6,u1,u2,u3,u4,u5,u6)');

maple(['kde:={'...
    'seq(LinearVelocity(W,Tree)'...
        '&oo MakeTranslations(w,i)=cat(u,i),i=1..3),'...
    'seq(AngularVelocity(w,tree)'...
        '&oo MakeTranslations(tree,i)=cat(u,i+3),i=1..3)}']);

maple('p:=subs(kde,LinearMomentum(W,Tree))');
maple('h:=subs(kde,AngularMomentum(W,tree))');

maple('depth1:=FindTranslation(Hill,Tree1) &oo MakeTranslations(hill,3)');
maple('depth2:=FindTranslation(Hill,Tree2) &oo MakeTranslations(hill,3)');

maple('gravity:=MakeTranslations(w,0,0,-M*g)');
maple('normal1:= (-scale * depth1) &** MakeTranslations(hill,3)');
maple('normal2:= (-scale * depth2) &** MakeTranslations(hill,3)');
maple('vel:=LinearVelocity(Hill,Tree)');
%maple(['notnorm:= vel &-- ((vel &oo MakeTranslations(hill,3))'...
%    '&** MakeTranslations(hill,3))']);
maple('friction:= (1/VectorLength(vel)) &** vel');
%maple('friction:= NullVector()');

maple('force1:= normal1 &++ (VectorLength(normal1) &** friction)');
maple('force2:= normal2 &++ (VectorLength(normal2) &** friction)');

maple('r1:=FindTranslation(Tree,Tree1)');
maple('r2:=FindTranslation(Tree,Tree2)');

%maple('a:=(1/12)*M*(3*R^2+L^2)');
%maple('c:=M*R^2/2');
maple('a:=0.343');
maple('c:=0.020');

maple(['dde:={'...
    'seq((DiffTime(p,w) &-- gravity'...
        '&-- ((1 - case1) &** force1)'...
        '&-- ((1 - case2) &** force2))'...
        '&oo MakeTranslations(w,i)=0,i=1..3),'...
    'seq((DiffTime(h,w)'...
        '&-- ((1 - case1) &** (r1 &xx force1))'...
        '&-- ((1 - case2) &** (r2 &xx force2)))'...
        '&oo MakeTranslations(w,i)=0,i=1..3)}']);

maple(['GeometryOutput('...
    'main=W,states=[q1,q2,q3=2,q4=1,q5=1,q6=1,'...
    'u1,u2,u3,u4,u5,u6,case1,case2],'...
    'parameters=[p1,p2,p3,p4,p5=0.05,p6,'...
        'seq(seq(cat(Inertia,i,j),i=1..3),j=1..3),'...
        'L=2,R=0.2,M=1,g=10,scale=10000],'...
    'checkargs,filename="treedrop.geo")']);
maple(['MotionOutput('...
    'ode=kde union dde,states=[q1,q2,q3=2,q4=1,q5=1,q6=1,'...
    'u1,u2,u3,u4,u5,u6],'...
    'insignals='...
        '[case1=(depth1&>0),case2=(depth2&>0)],'...
    'parameters=[p1,p2,p3,p4,p5=0.05,p6,'...
        'Inertia11=a,Inertia12,Inertia13,'...
        'Inertia21,Inertia22=a,Inertia23,'...
        'Inertia31,Inertia32,Inertia33=c,'...
        'L=2,R=0.2,M=1,g=10,scale=10000],'...        
    'checksings,checkargs,filename="treedrop.dyn")']);

% Ok. Here's what you need to do. Solve the kde's for the derivatives
% of the configuration coordinates in terms of the independent velocity
% coordinates. Substitute the result into the computation for the
% LinearVelocity, so that 'vel' is a function of the q's and u's, but
% not of the qt's. That should do it.